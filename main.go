package main

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"os"
	"reflect"
	"strings"
	"unicode"

	"golang.org/x/tools/imports"
)

func main() {
	var name string
	flag.StringVar(&name, "name", "AutoGenerated", "A root type name to use")
	flag.Parse()

	data, err := io.ReadAll(os.Stdin)
	maybeFatal(err)

	var obj any
	err = json.Unmarshal(data, &obj)
	maybeFatal(err)

	typeMeta := anyToType(obj)
	contents := formatWithName(name, typeMeta)
	contentsFormatted, err := imports.Process("autogen.go", []byte(contents), nil)
	maybeFatal(err)

	fmt.Println(string(contentsFormatted))
}

func maybeFatal(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "%+v\n", err)
		os.Exit(1)
	}
}

func formatWithName(name string, typeMeta Node) string {
	builder := new(strings.Builder)

	builder.WriteString("package autogen\n")
	builder.WriteString("\n")
	if typeMeta.Kind() == KindObject {
		if len(typeMeta.(Object).Fields) == 0 {
			builder.WriteString(fmt.Sprintf("type %s any\n", name))
			return builder.String()
		}
		builder.WriteString(fmt.Sprintf("type %s struct {\n", name))
		for name, node := range typeMeta.(Object).Fields {
			builder.WriteString(formatWithNameInner(name, 1, node))
		}
		builder.WriteString("}")
		return builder.String()
	}
	if typeMeta.Kind() == KindArray {
		if typeMeta.(Array).Type.Kind() == KindPrimitive {
			primitiveName := typeMeta.(Array).Type.(Primitive)
			builder.WriteString(fmt.Sprintf("type %s []%s", name, primitiveName))
			return builder.String()
		}
		if typeMeta.(Array).Type.Kind() == KindObject {
			if len(typeMeta.(Array).Type.(Object).Fields) == 0 {
				builder.WriteString(fmt.Sprintf("type %s []any\n", name))
				return builder.String()
			}
			builder.WriteString(fmt.Sprintf("type %s []struct {\n", name))
			builder.WriteString(formatWithNameInner(name, 1, typeMeta.(Array).Type))
			builder.WriteString("}")
			return builder.String()
		}
		if typeMeta.(Array).Type.Kind() == KindArray {
			builder.WriteString(fmt.Sprintf("type %s [][]any\n", name))
			return builder.String()
		}
	}
	if typeMeta.Kind() == KindPrimitive {
		return fmt.Sprintf("type %s %s", name, typeMeta.(Primitive))
	}
	return fmt.Sprintf("type %s any", name)
}

func formatWithNameInner(name string, indent int, typeMeta Node) string {
	indentTabs := strings.Repeat("\t", indent)
	builder := new(strings.Builder)
	if typeMeta.Kind() == KindPrimitive {
		primitiveName := typeMeta.(Primitive)
		builder.WriteString(fmt.Sprintf("%s%s %s `json:\"%s,omitempty\"`\n", indentTabs, fieldNameForName(name), primitiveName, name))
	} else if typeMeta.Kind() == KindObject {
		if len(typeMeta.(Object).Fields) == 0 {
			builder.WriteString(fmt.Sprintf("%s%s any `json:\"%s,omitempty\"`\n", indentTabs, fieldNameForName(name), name))
			return builder.String()
		}
		builder.WriteString(fmt.Sprintf("%s%s struct {\n", indentTabs, fieldNameForName(name)))
		for name, field := range typeMeta.(Object).Fields {
			builder.WriteString(formatWithNameInner(name, indent+1, field))
		}
		builder.WriteString(fmt.Sprintf("%s} `json:\"%s,omitempty\"`\n", indentTabs, name))
	} else if typeMeta.Kind() == KindArray {

	} else {
		builder.WriteString(fmt.Sprintf("%s%s any `json:\"%s,omitempty\"`\n", indentTabs, fieldNameForName(name), name))
	}
	return builder.String()
}

func fieldNameForName(name string) string {
	if name == "" {
		panic("invalid name!")
	}
	nameRunes := []rune(name)
	nameRunes[0] = unicode.ToUpper(nameRunes[0])
	for x := 1; x < len(nameRunes); x++ {

	}
	return string(nameRunes)
}

func anyToType(obj any) Node {
	if obj == nil {
		return Null{}
	}

	switch typed := obj.(type) {
	case map[string]any:
		output := Object{
			Fields: make(map[string]Node),
		}
		for key, value := range typed {
			output.Fields[key] = anyToType(value)
		}
		return output
	case bool, string, float64:
		return Primitive(fmt.Sprintf("%T", typed))
	default:
		rv := reflect.ValueOf(typed)
		// at this point we can only handle a slice of ???
		if rv.Kind() != reflect.Slice {
			panic(fmt.Errorf("invalid type %T for type metadata serialization", typed))
		}
		length := rv.Len()

		// figure out if we're seeing a "mixed" array
		kindsSeen := make(Set[Kind])
		primitivesSeen := make(Set[Primitive])
		for x := 0; x < length; x++ {
			elemNode := anyToType(rv.Index(x).Interface())
			kind := elemNode.Kind()
			kindsSeen.Add(kind)
			if kind == KindPrimitive {
				primitivesSeen.Add(elemNode.(Primitive))
			}
		}
		if kindsSeen.Has(KindNull) {
			kindsSeen.Remove(KindNull)
		}
		if len(kindsSeen) == 0 || len(kindsSeen) > 1 {
			return Array{Type: Any{}}
		}

		var output Node
		arrayKind, _ := kindsSeen.First()
		if arrayKind == KindPrimitive {
			if len(primitivesSeen) == 1 {
				output, _ = primitivesSeen.First()
				return Array{Type: output}
			}
			return Array{Type: Any{}}
		} else if arrayKind == KindObject {
			obj := Object{
				Fields: make(map[string]Node),
			}
			for x := 0; x < length; x++ {
				node := anyToType(rv.Index(x).Interface())
				if typed, ok := node.(Object); ok {
					for key, field := range typed.Fields {
						existingField, hasField := obj.Fields[key]
						if !hasField {
							obj.Fields[key] = field
							continue
						}
						if existingField.Kind() == KindAny {
							continue
						}
						if existingField.Kind() == KindNull && field.Kind() != KindNull {
							obj.Fields[key] = field
							continue
						}
						if existingField.Signature() == field.Signature() {
							continue
						}
						obj.Fields[key] = Any{}
					}
				}
			}
			return Array{Type: obj}
		} else if arrayKind == KindArray {
			return Array{Type: Array{Type: Any{}}}
		}
		return Array{Type: Any{}}
	}
}

type Set[T comparable] map[T]struct{}

func (s Set[T]) First() (k T, ok bool) {
	for k = range s {
		ok = true
		return
	}
	return
}

func (s Set[T]) Add(k T) {
	s[k] = struct{}{}
}

func (s Set[T]) Has(k T) (ok bool) {
	_, ok = s[k]
	return
}

func (s Set[T]) Remove(k T) {
	delete(s, k)
}

type Kind int

const (
	KindObject    Kind = iota
	KindArray     Kind = iota
	KindPrimitive Kind = iota
	KindNull      Kind = iota
	KindAny       Kind = iota
)

type Null struct{}

func (n Null) Kind() Kind { return KindNull }

func (n Null) Signature() string { return "null" }

type Any struct{}

func (a Any) Kind() Kind { return KindAny }

func (a Any) Signature() string { return "any" }

type Object struct {
	Fields map[string]Node
}

func (o Object) Kind() Kind { return KindObject }

func (o Object) Signature() string {
	buf := new(bytes.Buffer)
	for fieldName, fieldType := range o.Fields {
		buf.WriteString(fieldName + "||" + fieldType.Signature())
	}
	h := sha256.New()
	h.Write(buf.Bytes())
	return hex.EncodeToString(h.Sum(nil))
}

type Array struct {
	Type Node
}

func (a Array) Kind() Kind { return KindArray }

func (a Array) Signature() string { return "array" }

type Primitive string

func (p Primitive) Kind() Kind { return KindPrimitive }

func (p Primitive) Signature() string { return string(p) }

type Node interface {
	Kind() Kind
	Signature() string
}
