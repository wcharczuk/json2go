package main

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"os"
	"reflect"
	"sort"
	"strings"
	"unicode"

	"golang.org/x/tools/imports"
)

func main() {
	var packageName, name string
	var debug bool
	flag.StringVar(&packageName, "package", "autogen", "A package name to use")
	flag.StringVar(&name, "name", "AutoGenerated", "A root type name to use")
	flag.BoolVar(&debug, "debug", false, "Enable debug mode to show more output when there are errors")
	flag.Parse()

	data, err := io.ReadAll(os.Stdin)
	maybeFatal(err)

	var obj any
	err = json.Unmarshal(data, &obj)
	maybeFatal(err)

	typeMeta := anyToType(obj)

	aliasedTypes := aliasRepeatedTypes(typeMeta, []string{name})
	contents := formatWithName(packageName, name, typeMeta, aliasedTypes)
	contentsFormatted, err := imports.Process("autogen.go", []byte(contents), nil)
	if err != nil {
		if debug {
			fmt.Println(string(contents))
		}
		maybeFatal(err)
	}
	fmt.Println(string(contentsFormatted))
}

func maybeFatal(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "%+v\n", err)
		os.Exit(1)
	}
}

func formatWithName(packageName, name string, typeMeta Node, aliases map[string]*NodeAlias) string {
	builder := new(strings.Builder)

	builder.WriteString(fmt.Sprintf("package %s\n", packageName))
	builder.WriteString("\n")
	builder.WriteString(fmt.Sprintf("// %s is an autogenerated type from JSON.\n", name))
	builder.WriteString(formatWithNameTopLevel(name, typeMeta, aliases))
	builder.WriteString("\n")
	for _, aliasedType := range aliases {
		if aliasedType.Seen > 1 {
			builder.WriteString(fmt.Sprintf("// %s is an aliased type from JSON.\n", aliasedType.Alias))
			builder.WriteString(formatWithNameTopLevel(aliasedType.Alias, aliasedType.Node, aliases))
			builder.WriteString("\n")
		}
	}

	return builder.String()
}

func formatWithNameTopLevel(name string, typeMeta Node, aliases map[string]*NodeAlias) string {
	builder := new(strings.Builder)
	if typeMeta.Kind() == KindObject {
		if len(typeMeta.(Object).Fields) == 0 {
			builder.WriteString(fmt.Sprintf("type %s any\n", name))
			return builder.String()
		}
		builder.WriteString(fmt.Sprintf("type %s struct {\n", name))
		for _, fn := range typeMeta.(Object).FieldNames() {
			node := typeMeta.(Object).Fields[fn.JSON]
			builder.WriteString(formatWithNameInner(fn.JSON, 1, node, aliases))
		}
		builder.WriteString("}")
		return builder.String()
	} else if typeMeta.Kind() == KindArray {
		if typeMeta.(Array).Type.Kind() == KindPrimitive {
			primitiveName := typeMeta.(Array).Type.(Primitive)
			builder.WriteString(fmt.Sprintf("type %s []%s", name, primitiveName))
		} else if typeMeta.(Array).Type.Kind() == KindObject {
			if len(typeMeta.(Array).Type.(Object).Fields) == 0 {
				builder.WriteString(fmt.Sprintf("type %s []any\n", name))
			} else {
				builder.WriteString(fmt.Sprintf("type %s []struct {\n", name))
				builder.WriteString(formatWithNameInner(name, 1, typeMeta.(Array).Type, aliases))
				builder.WriteString("}")
			}
		} else if typeMeta.(Array).Type.Kind() == KindArray {
			builder.WriteString(fmt.Sprintf("type %s [][]any\n", name))
		}
	} else if typeMeta.Kind() == KindPrimitive {
		builder.WriteString(fmt.Sprintf("type %s %s", name, typeMeta.(Primitive)))
	} else {
		builder.WriteString(fmt.Sprintf("type %s any", name))
	}
	return builder.String()
}

func formatWithNameInner(name string, indent int, typeMeta Node, aliases map[string]*NodeAlias) string {
	indentTabs := strings.Repeat("\t", indent)
	builder := new(strings.Builder)

	if aliasedType, ok := aliases[typeMeta.Signature()]; ok && aliasedType.Seen > 1 {
		builder.WriteString(fmt.Sprintf("%s%s %s `json:\"%s,omitempty\"`\n", indentTabs, fieldNameForName(name), aliasedType.Alias, name))
		return builder.String()
	}

	if typeMeta.Kind() == KindPrimitive {
		primitiveName := typeMeta.(Primitive)
		builder.WriteString(fmt.Sprintf("%s%s %s `json:\"%s,omitempty\"`\n", indentTabs, fieldNameForName(name), primitiveName, name))
		return builder.String()
	} else if typeMeta.Kind() == KindObject {
		if len(typeMeta.(Object).Fields) == 0 {
			builder.WriteString(fmt.Sprintf("%s%s any `json:\"%s,omitempty\"`\n", indentTabs, fieldNameForName(name), name))
			return builder.String()
		}
		builder.WriteString(fmt.Sprintf("%s%s struct {\n", indentTabs, fieldNameForName(name)))
		for _, fn := range typeMeta.(Object).FieldNames() {
			field := typeMeta.(Object).Fields[fn.JSON]
			builder.WriteString(formatWithNameInner(fn.JSON, indent+1, field, aliases))
		}
		builder.WriteString(fmt.Sprintf("%s} `json:\"%s,omitempty\"`\n", indentTabs, name))
		return builder.String()
	} else if typeMeta.Kind() == KindArray {
		arrayType := typeMeta.(Array).Type
		if aliasedArrayType, ok := aliases[arrayType.Signature()]; ok && aliasedArrayType.Seen > 1 {
			builder.WriteString(fmt.Sprintf("%s%s []%s `json:\"%s,omitempty\"`\n", indentTabs, fieldNameForName(name), aliasedArrayType.Alias, name))
			return builder.String()
		}
		if arrayType.Kind() == KindPrimitive {
			builder.WriteString(fmt.Sprintf("%s%s []%s `json:\"%s,omitempty\"`\n", indentTabs, fieldNameForName(name), arrayType.(Primitive), name))
			return builder.String()
		}
		if arrayType.Kind() == KindObject {
			builder.WriteString(fmt.Sprintf("%s%s []struct {\n", indentTabs, fieldNameForName(name)))
			for _, fn := range arrayType.(Object).FieldNames() {
				field := arrayType.(Object).Fields[fn.JSON]
				builder.WriteString(formatWithNameInner(fn.JSON, indent+1, field, aliases))
			}
			builder.WriteString(fmt.Sprintf("%s} `json:\"%s,omitempty\"`\n", indentTabs, name))
			return builder.String()
		}
		builder.WriteString(fmt.Sprintf("%s%s []any `json:\"%s,omitempty\"`\n", indentTabs, fieldNameForName(name), name))
		return builder.String()
	}
	builder.WriteString(fmt.Sprintf("%s%s any `json:\"%s,omitempty\"`\n", indentTabs, fieldNameForName(name), name))
	return builder.String()
}

func fieldNameForName(name string) string {
	if name == "" {
		return ""
	}

	nameRunes := []rune(name)
	outputRunes := make([]rune, 0, len(nameRunes))
	var nextUppercase bool
	for x := 0; x < len(nameRunes); x++ {
		if len(outputRunes) == 0 /* is the first output rune */ {
			// we _cannot_ start with a non letter!
			if !unicode.IsLetter(nameRunes[x]) {
				continue
			}

			// make the first output rune uppercase always
			outputRunes = append(outputRunes, unicode.ToUpper(nameRunes[x]))
			continue
		}

		if nameRunes[x] == '_' || unicode.IsSpace(nameRunes[x]) {
			nextUppercase = true
			continue
		}

		if !(unicode.IsLetter(nameRunes[x]) || unicode.IsDigit(nameRunes[x])) {
			nextUppercase = true
			continue
		}

		if nextUppercase {
			outputRunes = append(outputRunes, unicode.ToUpper(nameRunes[x]))
			nextUppercase = false
		} else {
			outputRunes = append(outputRunes, nameRunes[x])
		}
	}
	outputStr := string(outputRunes)
	// correct `Id` instances
	if strings.HasSuffix(outputStr, "Id") {
		outputStr = strings.TrimSuffix(outputStr, "Id")
		outputStr = outputStr + "ID"
	}
	// correct `Url` instances
	if strings.HasSuffix(outputStr, "Url") {
		outputStr = strings.TrimSuffix(outputStr, "Url")
		outputStr = outputStr + "URL"
	}
	return outputStr
}

type NodeAlias struct {
	Alias string
	Node  Node
	Seen  int
}

func aliasRepeatedTypes(root Node, path []string) map[string]*NodeAlias {
	var output = make(map[string]*NodeAlias)
	switch typed := root.(type) {
	case Array:
		inner := aliasRepeatedTypes(typed.Type, path)
		for sig, alias := range inner {
			if _, ok := output[sig]; !ok {
				output[sig] = alias
			} else {
				output[sig].Seen++
			}
		}
	case Object:
		output[typed.Signature()] = &NodeAlias{
			Alias: strings.Join(path, "_"),
			Node:  typed,
			Seen:  1,
		}
		for _, fn := range typed.FieldNames() {
			field := typed.Fields[fn.JSON]
			innerPath := cloneAppend(path, fn.Go)
			inner := aliasRepeatedTypes(field, innerPath)
			for sig, alias := range inner {
				if _, ok := output[sig]; !ok {
					output[sig] = alias
				} else {
					output[sig].Seen++
				}
			}
		}
	}
	return output
}

func cloneAppend(values []string, newValue string) []string {
	output := make([]string, len(values), len(values)+1)
	copy(output, values)
	output = append(output, newValue)
	return output
}

func anyToType(obj any) Node {
	if obj == nil {
		return Null{}
	}
	switch typed := obj.(type) {
	case map[string]any:
		output := Object{
			Fields: make(map[string]Node),
		}
		for key, value := range typed {
			output.Fields[key] = anyToType(value)
		}
		return output
	case bool, string, float64:
		return Primitive(fmt.Sprintf("%T", typed))
	default:
		rv := reflect.ValueOf(typed)
		// at this point we can only handle a slice of ???
		if rv.Kind() != reflect.Slice {
			panic(fmt.Errorf("invalid type %T for type metadata serialization", typed))
		}
		length := rv.Len()
		// figure out if we're seeing a "mixed" array
		kindsSeen := make(Set[Kind])
		primitivesSeen := make(Set[Primitive])
		for x := 0; x < length; x++ {
			elemNode := anyToType(rv.Index(x).Interface())
			kind := elemNode.Kind()
			kindsSeen.Add(kind)
			if kind == KindPrimitive {
				primitivesSeen.Add(elemNode.(Primitive))
			}
		}
		if kindsSeen.Has(KindNull) {
			kindsSeen.Remove(KindNull)
		}
		if len(kindsSeen) == 0 || len(kindsSeen) > 1 {
			return Array{Type: Any{}}
		}

		var output Node
		arrayKind, _ := kindsSeen.First()
		if arrayKind == KindPrimitive {
			if len(primitivesSeen) == 1 {
				output, _ = primitivesSeen.First()
				return Array{Type: output}
			}
			return Array{Type: Any{}}
		} else if arrayKind == KindObject {
			obj := Object{
				Fields: make(map[string]Node),
			}
			for x := 0; x < length; x++ {
				node := anyToType(rv.Index(x).Interface())
				if typed, ok := node.(Object); ok {
					for key, field := range typed.Fields {
						existingField, hasField := obj.Fields[key]
						if !hasField {
							obj.Fields[key] = field
							continue
						}
						if existingField.Kind() == KindAny {
							continue
						}
						if existingField.Kind() == KindNull && field.Kind() != KindNull {
							obj.Fields[key] = field
							continue
						}
						if existingField.Signature() == field.Signature() {
							continue
						}
						obj.Fields[key] = Any{}
					}
				}
			}
			return Array{Type: obj}
		} else if arrayKind == KindArray {
			return Array{Type: Array{Type: Any{}}}
		}
		return Array{Type: Any{}}
	}
}

type Set[T comparable] map[T]struct{}

func (s Set[T]) First() (k T, ok bool) {
	for k = range s {
		ok = true
		return
	}
	return
}

func (s Set[T]) Add(k T) {
	s[k] = struct{}{}
}

func (s Set[T]) Has(k T) (ok bool) {
	_, ok = s[k]
	return
}

func (s Set[T]) Remove(k T) {
	delete(s, k)
}

type Kind int

const (
	KindObject    Kind = iota
	KindArray     Kind = iota
	KindPrimitive Kind = iota
	KindNull      Kind = iota
	KindAny       Kind = iota
)

type Null struct{}

func (n Null) Kind() Kind { return KindNull }

func (n Null) Signature() string { return "null" }

type Any struct{}

func (a Any) Kind() Kind { return KindAny }

func (a Any) Signature() string { return "any" }

type Object struct {
	Fields map[string]Node
}

type FieldName struct {
	JSON string
	Go   string
}

func (o Object) FieldNames() []FieldName {
	output := make([]FieldName, 0, len(o.Fields))
	duplicates := make(map[string]int)
	for name := range o.Fields {
		goName := fieldNameForName(name)
		duplicates[goName]++
		if count := duplicates[goName]; count > 1 {
			goName = fmt.Sprintf("%s_%d", goName, count)
		}
		output = append(output, FieldName{
			JSON: name,
			Go:   goName,
		})
	}
	sort.Slice(output, func(i, j int) bool {
		return output[i].Go < output[j].Go
	})
	return output
}

func (o Object) Kind() Kind { return KindObject }

func (o Object) Signature() string {
	buf := new(bytes.Buffer)
	for _, fieldName := range o.FieldNames() {
		fieldType := o.Fields[fieldName.JSON]
		buf.WriteString(fieldName.JSON + "||" + fieldType.Signature())
	}
	h := sha256.New()
	h.Write(buf.Bytes())
	return hex.EncodeToString(h.Sum(nil))
}

type Array struct {
	Type Node
}

func (a Array) Kind() Kind { return KindArray }

func (a Array) Signature() string { return "array" }

type Primitive string

func (p Primitive) Kind() Kind { return KindPrimitive }

func (p Primitive) Signature() string { return string(p) }

type Node interface {
	Kind() Kind
	Signature() string
}
